PA2 Semestrální práce, Kryštof Klen
Téma - Šachy

----------------------------------------------------------------------------------
Architektura hry:
Ve hře používám NCURSES, díky čemuž vytvořím v terminálu GUI, terminál musí mít povolené barvy,
jinak od sebe nepudou některé věci rozlišit.

Až na drobnosti je semestrální práce skoro hotová.

Úvod:
    Klasická hra šachy.
    Hra je rozdělena do adresárů, ve kterých se nacházejí třídy vykonávající kód
    odpovídající názvu adresáře. (např. v adresáři FileOperations jsou třídz a funkce související
    s čtením, zpracováním a ukládáním dat hry do souboru).
    K dispozici je i soubor file.conf, kde si uživatel může nadefinovat proměnné, které budou
    při startu programu ze souboru načteny, uživatel tak může např. ovlivnit chování AI.

Nejdůležitejší adresáře:

UI:
	Obsahuje vše, co nějakým způsobem používá NCURSES.
	Účelem kódu v tomto adresáři je jen čistě zobrazení
	a UI. Když např. hráč chce provést nepatný tah, tak 
	kód v UI mu v tom nezabrání. O to se starají třídy
	v jiných příslušných adresářích.
	Jediné, co se v UI kontroluje, jsou věci, které jsou 
	s UI přímo spjaté (např. aby člověk když vybírá pozici 
	nevyjel z obrazovky atd..)

FileOperations: Obsahuje kód sloužící k zapisování, čtení ze souboru a parsování dat.

Game: Obsahuje další podadresáře, vše co souvisí čistě s logikou šachů (pohyby, minmax, pravidla ...) je zde.

API: Propojuje FileOperations, Game a UI.

Application: Taková "obalovací/zastiňovací trída", abz mohla hra být přehledně spustitelná z main.ComputerPlayer

config: Souvisí s prací s konfiguračním souborem file.conf, a nastavením proměnných pro program.

-----------------------------------------------------------------------
Polymorfismus 1:
	Základem všeho je Piece.h, to reprezentuje libovolnou figurku na šachovnici.
	Když si hráč vybere na šachovnici figurku, se kterou chce hrát, tak se
	musí ověřit, že tah je v souladu s pravidly.
	To se dělá jednoduše, Piece.h má virtuální metodu 
	void getPossibleMovePositions(std::list<std::pair<int,int>> & possiblePositions),
	tato metoda, jak název napovídá vygeneruje tahové možnosti figurky.
    Ty má ale každá figurka jiné, právě tady uplatním polymorfismus.
	Z Piece dědí pak konkrétní figurky (King,Queen,Pawn...), každá z těchto 
	tříd má implementaci getPossibleMovePositions jinou.
	Třída Board má v sobě static Position playField [8][8], což je 2-rozměrné pole, které obsahuje
	Position obsahuje různé indikátory (např jestli je pozice volná atd.), které usnadňují 
	implementaci pravidel, každá position má Piece* mPiece -- pointer na dynamicky alokovaný
	Piece, která může být jakákoliv (King,Queen, Pawn ...)

	Při kontrole, zda hráč udělal tah v souladu s pravidly:
	1) z UI se vezmou souřadnice
	2) v playField se najde podle souřadnic Position
	3) Position má pointer na Piece.
	4) Zavolá se piece.getPossiblePositions
	5) Díky dynamické vazbě a polymorfnímu chování se odkáže na Třídu, která 
	z Figure dědí, a která má tuto metodu implementovanou tak, jak ji daný typ figurky vyžaduje
	6) Zkontroluje se, že uživatelem vybraná pozice na kterou chce táhnout je 
	v std::list<std::pair<int,int>>  possiblePositions, který je parametrem
	void getPossibleMovePositions(std::list<std::pair<int,int>> & possiblePositions)
	
	Polymorfismus zde výrazně ulehčuje implementaci pravidel.
	
Polymorfismus 2:
	Také v UI, princip podobný jako u getPossibleMovePositions(std::list<std::pair<int,int>> & possiblePositions),
     akorát když potřebuju zobrazit figurky (každá figurka reprezentována písmenem..
	King = K, Queen = Q, Pawn = P...), tak akorát zavolám figure.mLetter, kde z piece dědí King,
	Queen.. a písmeno reprezentující figurku se díky dynamické vazbě doplní.

Polymorfismus 3: 
    Analogicky jako u předchozího případu, tentokrát v algorytmu min max použiju piece.getRank, což mi 
    vrátí rank (díky polymorfismu) konkrétní figurky.

Polymorfismus 4:
    Při startu hry se volá funkce startGameLoop(), tato funkce je deklarovaná v GameControl, ze které dědí 
    OnePlayerGame a TwoPlayersGame.
    Díky polymorfismu se zavolá správná implementace (podle toho zda si hráč vybere hru proti PC, nebo hru ě hráčů).

Polymorfismus 5:
    funkce makeNextMove() v ComputerPlayer, má různé implementace podle toho, jakou hráč zvolil obtížnost hry.
-----------------------------------------------------------------------------------------------
úrovně AI:
	1) easy - naprosto náhodné tahy
	2) mid - náhodné tahy, ale pokud půjde někoho vyhodit, tak se vyhodí 
    (vyhodí se hodnotnější figurka, hodnoty  definovatelné v file.conf).
	3) diffuct - použití MINMAX (hloubka modifikovatelná v file.conf)	
-----------------------------------------------------------------------------------------------
Hra nabízí také tutoriál, kde je hráč upozorněn na figurkz, které může vyhodit a které může vyhodit.

